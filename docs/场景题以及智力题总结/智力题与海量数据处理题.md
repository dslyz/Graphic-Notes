# 智力题

## 1. 分金条问题 

-  **问题：** 你让工人为你工作7天，回报是一根金条，这个金条平分成相连的7段，你必须在每天结束的时候给他们一段金条。如果只允许你两次把金条弄断，你如何给你的工人付费？ 

- 解答：

  切两刀，分为1/7、2/7、4/7三段。   

  >  第一天给 1/7；
  >  第二天给 2/7，要回 1/7；
  >  第三天给 1/7 ；
  >  第四天给 4/7 要回 1/7 + 2/7；
  >  第五天给 1/7；
  >  第六天给 2/7，要回 1/7；
  >  第七天给 1/7 

##  2. 飞鸟问题 

-  **问题：**有一辆火车以每小时 15 公里的速度离开北京直奔广州，同时另一辆火车每小时 20 公里的速度从广州开往北京。如果有一只鸟，以 30 公里每小时的速度和两辆火车同时启动，从北京出发，碰到另一辆车后就向相反的方向返回去飞，就这样依次在两辆火车之间来回地飞，直到两辆火车相遇。请问，这只鸟共飞行了多长的距离？ 
-  **分析：**鸟在火车相遇前一直在飞，所以不论它如何往返，鸟飞的距离就是其速度乘时间，而时间则是用两列火车相遇的时间。设北京到广州的距离为 D，那么火车相遇时间是：D / (15+20)，由此可得鸟飞的距离是：30 * 时间 = 30/35 * D。 
-  **解答：**北京到广州距离的 30/35 

##  3. 药丸问题 

-  **问题：**你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的药丸的重量+1。只称量一次，如何判断哪个罐子的药被污染了？ 
-  **解答：**设未被污染的每个药丸的重量是x，则被污染的每个药丸的重量是x+1。将4个罐子分别标注为1，2、3、4，取一号罐子1个药丸，二号罐子2个药丸，三号罐子3个药丸，四号罐子4个药丸，一起称重。则： 

>   若一号罐子药丸被污染，则重量为（10x+1)； 
>    若二号罐子药丸被污染，则重量为（10x+2)； 
>    若三号罐子药丸被污染，则重量为（10x+3)； 
>    若四号罐子药丸被污染，则重量为（10x+4)。 

 即称得的重量是10X+t，t是几就是第几个罐子污染了。 

##  4. 开关问题 

-  **问题：**门外三个开关分别对应室内三盏灯，线路良好，在门外控制开关时候不能看到室内灯的情况，现在只允许进门一次，确定开关和灯的对应关系？ 
-  **解答：**设三个开关是1、2、3。打开开关1等半个小时，关上开关1并打开开关2。进房后去摸灯泡，热的是开关1对应的灯泡；亮的是开关2对应的灯泡；不亮不热的是开关3对应的灯泡。 

##  5. 人民币问题 

-  **问题：**人民币为什么只有1、2、5、10的面值？ 
-  **解答：**可以用三张以内组成任何面额。 

##  6. 烧绳计时问题 

-  **问题：** 烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？ 

- 解答：

  > 1.  先把1根绳子从两头点燃,燃烧完毕后刚好30分钟。 
  > 2.  在第1根绳子点燃的同时,从一头点燃第2根,那么在第1根然后完毕后(30分钟),再把第2根绳子未点燃的那一头点燃,燃烧完毕后用去了45分钟(30+15)。 
  > 3.  在第2根绳子燃烧完毕后,从两头点燃第3根绳子,等第3根燃烧完毕后,刚好1小时15分钟(45+30)。 

##  7. 果冻问题 

-  **问题：**你有一桶果冻，其中有红色、绿色、蓝色三种，闭上眼睛抓取同种颜色的两个。抓取多少个就可以确定你肯定有两个同一颜色的果冻？ 
-  **解答：**4个 

##  8. 量水问题 

-  **问题：**如果你有无穷多的水，一个3公升的提捅，一个5公升的提捅，两只提捅形状上下都不均匀，问你如何才能准确称出4公升的水? 

-  **分析：**这个题目等价于：已知两个数3和5，可用运算符+和-，要求+和-号的一端必须是3或5，并且中间结果不能大于5，列出一个结果等于4的表达式。 

- 解答：

  >  解法一：5 - (3 - (5 - 3)) 
  >
  > 1.  用5升桶满桶，倒入3升桶中，倒满后大桶里剩2升； 
  > 2.  把3升桶倒空，把那2升倒入3升桶中； 
  > 3.  用5升桶满桶再向3升里倒，倒入一升就满，大桶里剩下的是4 升。 
  >
  >  解法二：3 -(5 - 3) + 3 
  >
  > 1.  两次将3升桶满桶，倒入5升桶中，倒满后3升桶中剩1升； 
  > 2.  将5升桶倒空，把3升桶中的1升倒入5升桶中； 
  > 3.  将3升桶满桶倒入5升桶中。现在5升桶中包含4升。 

##  9. 诚实国和说谎国问题 

-  **问题：**一个岔路口分别通向诚实国和说谎国。来了两个人，已知一个是诚实国的，另一个是说谎国的。诚实国永远说实话，说谎国永远说谎话。现在你要去说谎国，但不知道应该走哪条路，需要问这两个人。请问应该怎么问? 
-  **分析：**如果问 “哪边是诚实国？” 或者 “哪边是说谎国？” 这样的问题，由于正确答案只有固定的一边，所以两个人给出的答案必定不同。所以只能问对每个人有不同正确答案的问题，比如“你的国家在哪边？”或者“他的国家在哪边”。对应着两个问题，诚实国的人会给出诚实国方向和说谎国方向，说谎国的人也会给出诚实国和说谎国方向。这样我们就可以判断哪边是诚实国，哪边是说谎国了。 
-  **解答：**问 你的国家怎么走? 他们都会指向诚实国，则走另一条路即可。 

##  10. 4人过桥问题 

-  **问题：**4 个人晚上要穿过一座索桥回到他们的营地。可惜他们手上只有一支只能再坚持17分钟的手电筒。通过索桥必须要拿着手电，而且索桥每次只能撑得起两个人的份量。这四个人过索桥的速度都不一样，第一个走过索桥需要1分钟，第二个2分钟，第三个5分钟，最慢的那个要10分钟。他们怎样才能在17分钟内全部走过索桥？ 

- 分析：

  | 过桥走法               | 花费时间 |
  | ---------------------- | -------- |
  | 第一个和第二个一起过去 | 2 分钟   |
  | 第一个回来             | 1分钟    |
  | 第三个和第四个一起过去 | 10分钟   |
  | 第二个回来             | 2 分钟   |
  | 第一个和第二个一起过去 | 2 分钟   |

-  解答：总共花时 2 + 1 + 10 + 2 + 2 = 17 分钟。



## 11. 拿硬币问题 

-  **问题：**16个硬币，A和B轮流拿走一些，每次拿走的个数只能是1，2，4中的一个数。谁最后拿硬币谁输。请问：A或B有无策略保证自己赢？ 

- 解答：

  B可以保证自己赢。   

  > -  如果A拿1个，则B拿2个； 
  > -  如果A拿2个，则B拿1个； 
  > -  如果A拿4个，则B拿2个。
  >    这样每次AB加起来都是3或者6，所以最后会剩下1个或4个。 
  > -  如果是1个则A直接输了； 
  > -  如果剩下4个，A全拿则输了，如果不全拿，B继续采取上面的策略，最后还是剩下1个，还是A输。 

##  12. 辩论赛问题 

-  **问题：**1000个人参加辩论赛，1对1进行辩论，淘汰输掉的一方，问需要安排多少场比赛才能角出冠军？ 
-  **解答：**每场辩论赛只能淘汰一个人，要淘汰999个人则需要安排999场比赛。 

##  13. 火车运煤问题 

-  **问题：**你是山西的一个煤老板，你在矿区开采了有 3000 吨煤需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列烧煤的火车，这个火车最多只能装1000吨煤，且其能耗比较大，每一公里需要耗一吨煤。请问，怎么运送才能运最多的煤到集市？ 

- 解答：

  > 1.  装 1000 吨煤，走 250 公里，扔下 500 吨煤，回矿山； 
  > 2.  装 1000 吨煤，走到 250 公里处，拿起 250 吨煤继续向前到 500 公里处，扔下 500 吨煤，回矿山。此时火车上还有 250 吨，再加上在 250 公里处还有 250 吨煤，所以，火车是可以回矿山的； 
  > 3.  装上最后 1000 吨煤，走到 500 公里处，装上那里的 500 吨煤，然后一直走到目的； 
  > 4.  由此，最多可以运送 500 吨煤到市场（当然，火车也回不去了，因为那矿山没有煤了）。 

##  14. 旅馆的1元钱问题 

-  **问题：**有三个人去住旅馆，住三间房，每一间房10元，于是他们一共付给老板30，第二天，老板觉得三间房只需要25元就够了，于是叫小弟退回5元给三位客人，谁知小弟贪心，只退回每人1元，自己偷偷拿了2元，这样以来便等于那三位客人每人各花了9元，于是三个人一共花了27元，再加上小弟独吞了2元，总共是29元.可是当初他们三个人一共付出30元，那么还有1元呢？ 
-  **解答：**这道题其实偷换了概念，他们所消费的27元里已经包括小弟贪污的2元了，再加退还的3元=30元。这30元的分布是：老板拿了25元，小弟拿了2元，三人各拿了1元。 

##  15. 老虎吃羊问题 

-  **问题：**在岛上有100只老虎和1只羊，老虎可以吃草，但他们更愿意吃羊。如果每次只有一只老虎可以吃羊，而且一旦他吃了羊，他自己就变成羊；而且所有的老虎都是聪明而且完全理性的，他们的第一要务是生存。请问最后这只羊会不会被吃？如果是n只老虎和一只羊呢？ 

- 解答：

  > -  1只老虎，肯定吃; 
  > -  2只老虎肯定不吃，否则就被另一只吃了; 
  > -  3只老虎，如果一只老虎吃掉了羊，这样问题就转换为2只老虎和1只羊的情况，显然另外两种老虎不敢轻举妄动，所以羊会被吃； 
  > -  4只老虎，如果某一只老虎吃了羊，问题转化为3只老虎和1只羊的问题，它肯定会被接下来的某一只吃掉，然后其他两只只能等着，所以4只老虎，大家都不敢吃羊； 
  > -  归纳：我们就可以发现如果老虎数目是奇数，那么羊肯定被吃，如果是偶数，那么羊肯定不会被吃。 

##  16. 假钱亏损问题 

-  **问题：**王小姐是卖鞋的，一双鞋进货价45元，甩卖30元。顾客来买两双鞋给了一张100元，王小姐没有零钱，于是找了邻铺兑换了100元零钱，找给顾客40元。事后邻铺发现钱是假的，王小姐无奈又赔了邻铺100元。请问，王小姐一共亏了多少元？ 
-  **解答：**亏130 元 

>  解法一： 
>
> -  假定王小姐一开始有 200 元，进了 2 双鞋，45 * 2 = 90 此时她还剩 200 - 90 = 110； 
> -  现在王小姐把鞋以 30 元一双的价格甩卖，2 双卖出后进账 30 * 2 = 60； 
> -  王小姐没有零钱，用 100 换了邻居 100，钱数没有变化，此时王小姐手中有 110 + 60 = 170； 
> -  这时邻居发现钱是假的，王小姐赔给邻居 100 元，此时王小姐手中钱数为 170 - 100 = 70； 
> -  王小姐手中一开始有 200，最后剩 70，赔了 200 - 70 = 130； 
> -  所以得出，王小姐亏了 130 元 。 

>  解法二： 
>
> -  王小姐收到一张 100 元假钞 （没得没失，所以是 0 ）； 
> -  王小姐把 100 元假钞给邻居，换回 100 元真钞 （假钞换真钞，得到了 100 ）； 
> -  王小姐把 2 双 90 元成本的鞋还有 40 元找零给了顾客 （失去了 90 + 40 = 130 元）； 
> -  王小姐被邻居发现那张一百是假的，于是只得赔给邻居 100 元 （失去了 100 元，先前用假钞换来的）； 
> -  所以王小姐最终亏了 130 元。 

>  解法三： 
>
> -  换钱的邻铺并没有赚钱，也没赔钱； 
> -  使假币的顾客相当于没花钱得到 2 双鞋（45 * 2 = 90）加上 40 元真币，所以相当于赚了 130 元； 
> -  所以最终是王小姐亏了 130 元。 

##  17. 赛马问题 

-  **问题：**25 匹马，每匹马的速度都不一样。因为只有 5 条跑道，所以一次竞赛只能跑 5 匹马，问最少需要多少次竞赛才能找到最快的 3 匹马？ 

- 分析：

  > -  25 = 5 * 5，首先将所有的马分为5组，每组5匹进行比赛； 
  >
  > -  假设5次竞赛后的结果是：      
  >
  >   | 假设比赛结果   | 比赛次数 |
  >   | -------------- | -------- |
  >   | 1>2>3>4>5      | 第1次    |
  >   | 6>7>8>9>10     | 第2次    |
  >   | 11>12>13>14>15 | 第3次    |
  >   | 16>17>18>19>20 | 第4次    |
  >   | 21>22>23>24>25 | 第5次    |
  >
  > -  将 1、6、11、16、21 再比一次，假设结果是：      
  >
  >   | 假设比赛结果 | 比赛次数 |
  >   | ------------ | -------- |
  >   | 1>6>11>16>21 | 第6次    |
  >
  > -  那么接下来最快的三匹马只可能在以下马中产生：
  >    1 > 2 > 3；
  >    6 > 7；
  >    11； 
  >
  > -  1是最快的马，接下来只需再比一次 2、3、6、7、11，即可知道另外两匹最快的马了；      
  >
  >   | 假设比赛结果 | 比赛次数 |
  >   | ------------ | -------- |
  >   | 11>7>6>2>3   | 第7次    |
  >
  > -  由此可得最快的三匹马是 1、11、7。 

-  **解答：**至少需要7次。 

##  18. 九点连十线问题 

-  **问题：**在9个点上画10条直线，要求每条直线上至少有三个点? 

- 解答：

  >  解法一：三横一竖 + 六斜 （如下图）
  >  ![图片说明](%E6%99%BA%E5%8A%9B%E9%A2%98%E4%B8%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%A2%98.assets/49D1E18836D2E95D96CC09A303398FDF)
  >  解法二：三竖一横 + 六斜（与解法一类似，如下图）
  >  ![图片说明](%E6%99%BA%E5%8A%9B%E9%A2%98%E4%B8%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%A2%98.assets/04512770CEC58E46DA42BEEAB36DEAFC) 

##  19. 移动竹签问题 

-  **问题：**如下图，只能移动两根竹签，而且形状不能改变，把围住的鸡蛋给移出来。（来自《少年包青天第一部》,第13集2分40秒 包拯到杂货店里买米,店老板出的题。）
   ![图片说明](%E6%99%BA%E5%8A%9B%E9%A2%98%E4%B8%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%A2%98.assets/8FBC646B94AB0BD47EDD91B9460B2C79) 

- 解答：

  >  第一步：
  >  ![图片说明](%E6%99%BA%E5%8A%9B%E9%A2%98%E4%B8%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%A2%98.assets/A3993FEB9C4D1D21EDA7B37ABAC04A15)
  >  第二步：
  >  ![图片说明](%E6%99%BA%E5%8A%9B%E9%A2%98%E4%B8%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%A2%98.assets/9414527FE288C8511E722F30C2A94F81)



## 21. 掰巧克力问题 

-  **问题：**一块N*M大小的巧克力，每次掰一块的一行或一列，全部掰成1*1大小的巧克力需要掰多少次？ 
-  **解答：**N*M-1次。因为不管怎么掰，每次只能把一个大块掰成两个小块，即每次掰只能增加1块巧克力；那么将1块巧克力掰成N*M块小巧克力就需要掰N*M-1次。 

##  22. 分蛋糕问题 

-  **问题：**请把一盒蛋糕切成8份，分给8个人，但蛋糕盒里还必须留有一份。 
-  **解答：**把切成的8份蛋糕先拿出7份分给7人，剩下的1份连蛋糕盒一起分给第8个人。 

##  23. 时针分针秒针重合问题 

-  **问题：**在24小时里面时针分针秒针可以重合几次 
-  **解答：**24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次。 

##  24. 箱子开锁问题 

-  **问题：**A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？ 

- 解答：

  > 1.  A 把药放进箱子，用自己的锁把箱子锁上； 
  > 2.  B 拿到箱子后，再在箱子上加一把自己的锁； 
  > 3.  箱子运回 A 后，A 取下自己的锁； 
  > 4.  箱子再运到 B 手中时，B 取下自己的锁，获得药物。 

##  25. 沙漏计时问题 

-  **问题：**有一个能计时6分钟的小沙漏和一个能计时8分钟的大沙漏，如何计时10分钟？ 

- 解答：

  > 1.  两个沙漏同时倒置开始计时，等小沙漏漏完，大沙漏还剩2分钟，这时倒置小沙漏继续计时； 
  > 2.  大沙漏漏完小沙漏还剩4分钟，再把大沙漏倒置继续计时； 
  > 3.  小沙漏漏完大沙漏还剩4分钟，这时准备工作已经完毕； 
  > 4.  等待大沙漏漏完（4分钟）+小沙漏（6分钟）=10分钟。 

##  26. 人鬼过桥问题 

-  **问题：**有三个人跟三个鬼要过河，河上没桥只有条小船，然后船一次只能渡一个人和一个鬼，或者两个鬼和两个人，无论在哪边岸上，只有是人比鬼少的情况下（如两鬼一人，三鬼两人，三鬼一人），人会被鬼吃掉，然而船有一定需要人或鬼操作才能航行（要有人或鬼划船），问，如何安全的把三人三鬼渡过河对岸？ 

- 解答：

  > 1.  先两鬼过去，再一鬼回来。此时，对面有一鬼，这边有三人两鬼； 
  > 2.  再两鬼过去，再一鬼回来。此时对面有两鬼，这边有三人一鬼； 
  > 3.  再两人过去，一人一鬼回来。此时，对面一人一鬼。这边两人两鬼； 
  > 4.  最后两人过去，一鬼回来。此时，对面三人，这边三鬼； 
  > 5.  剩下的就三个鬼，两个过去，一个回来再接另外一个鬼就结束了。 

##  27. 毒药问题 

-  **问题：**有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？ 

-  **解答：**将1000个瓶子从 0 到 999 依次按照十进制编号，之后根据十进制编号，转换为对应的2进制，比如：512（十进制）—> 1000000000（二进制），一共10位数的二进制，刚好对应10只老鼠。 

  >  编号右起第一位：第1只老鼠喝掉所有编号为1的水；
  >  编号右起第二位：第2只老鼠喝掉所有编号为1的水；
  >  编号右起第三位：第3只老鼠喝掉所有编号为1的水；
  >  …
  >  编号右起第十位：第10只老鼠喝掉所有编号为1的水。 

  >  一星期后，
  >  如果第1只老鼠死了，则：
  >  毒药瓶子的二进制编号中，右起第一位是 1 ；
  >  如果第1只老鼠没死，则：
  >  毒药瓶子的二进制编号中，右起第1位是 0 ；
  >  ⋯⋯
  >  以此类推,
  >  每只老鼠的死活都能确定出 10 位二进制数的其中一位，由此便可知道毒药瓶子的二进制编号了，进而转换为十进制，即可找出毒药瓶子。 

##  28. 吃药片问题 

-  **问题：**某种药方要求非常严格，你每天需要同时服用A、B两种药片各一颗，不能多也不能少。这种药非常贵，你不希望有任何一点的浪费。一天，你打开装药片A的药瓶，倒出一粒药片放在手心；然后打开另一个药瓶，但不小心倒出了两粒药片。现在，你手心上有一颗药片A，两颗药片B，并且你无法区别哪个是A，哪个是B。你如何才能严格遵循药方服用药片，并且不能有任何的浪费？ 

- 解答：

  > 1.  把手上的三片药各自切成两半，分成两堆摆放； 
  > 2.  再取出一粒药片 A，也把它切成两半，然后在每一堆里加上半片的 A； 
  > 3.  现在，每一堆药片恰好包含两个半片的 A 和两个半片的 B； 
  > 4.  一天服用其中一堆即可。 

##  29. 火枪手决斗，谁活下来的概率大？ 

-  **问题：**彼此痛恨的甲、乙、丙三个抢手准备决斗。甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中。如果三人同时开枪，并且每人每轮只发一枪；那么枪战后，谁活下来的机会大一些？ 

-  **解答：**枪法最糟糕的丙活下来的几率最大，前提是三人都清楚了解对手的实力。 

-  **分析：**
   **A. 第一轮枪战** 

  -  甲的最佳策略:先瞄准乙。因为乙对甲的威胁要比丙大，所以应该首先干掉乙。 
  -  乙的最佳策略:先瞄准甲。一旦将甲干掉了，和丙进行对决，乙胜算的概率要大得多。 
  -  丙的最佳策略:也是先瞄准甲。毕竟对丙来说，乙的威胁还是比甲要小一些，先努力干掉甲再想如何面对乙，这是丙的正常思路。 

   在这种情况下，我们计算一下三个枪手开枪后各自存活的概率: 

  -  甲存活:那就是乙丙都射偏。乙命中率60%，射偏概率是40%；丙命中率40%，射偏概率是60%。干是两人都射偏的概率40%X60%=24%，这就是甲存活的概率。 
  -  乙存活:那就是甲射偏。甲命中率80%，射偏概率是20%，这就是乙存活的概率。 
  -  丙存活:由于第一轮里无人将枪口指向丙，所以他存活概率是100%。 

   **结论：第一轮枪战，枪法最差的丙竟然存活概率最大——肯定存活，而枪法好的甲和乙存活概率远低于丙。** 

   **B. 第二轮枪战**
   第一轮后，丙有可能面对甲，也可能面对乙，甚至同时面对甲与乙，或者是甲乙皆死。 

  -  如果丙同时面对甲乙，则回到第一轮的情况。 
  -  如果甲乙皆死，则枪战结束，丙存活。 
  -  而如果丙单独面对甲或乙，命中率最低的丙的日子是最不好过的。 

   在这种情况下，我们再计算一下三个枪手开枪后各自存活的概率: 

  -  甲存活: 

    -  第一轮甲活乙死（24%*80%），第二轮甲活（60%）； 
    -  第一轮甲乙同活（24%*20%），重复第一轮，第二轮甲活（24%） 

     那么甲存活概率为：(24%*80%*60%)+(24%*20%*24%)=12.672% 

  -  乙存活: 

    -  第一轮乙活甲死（20%*76%），第二轮乙活（60%）； 
    -  第一轮甲乙同活（24%*20%），重复第一轮，第二轮乙活（20%） 

     那么乙存活概率为：(20%*76%*60%)+(24%*20%*20%)=10.08% 

  -  丙存活: 

    -  第一轮甲活乙死（24%*80%），第二轮丙活（20%）； 
    -  第一轮乙活甲死（20%*76%），第二轮丙活（40%）； 
    -  第一轮甲乙同活（24%*20%），重复第一轮，第二轮丙活（100%）； 
    -  第一轮甲乙同死（76%*80%），枪战结束，丙活（100%）。 

    ​      **那么丙存活概率为：** **(24%\*80%** ***** **20%)+(20%\*76%\*40%)+(24%** ***** **20%** ***** **100%)+(76%** ***** **80%\*100%)=75.52%。**



# 海量数据处理题

海量数据处理面试题其实有着很强的规律性，因为它们面临的场景都大同小异，那就是 **数据量太大了，而机器内存不足** ，无法直接将海量数据直接读进内存中进行处理。

此时我们常用的方法就是Hash映射、分而治之，将大数据切分为多块小数据，逐个击破，这其实也是Map Reduce的思想。除了空间复杂度的优化，我们还可以通过巧妙的**数据结构和算法**来优化时间复杂度，比如HashMap、BitMap、前缀树等数据结构和堆排序、topk等算法。



## 1、海量日志数据，提取出某日访问[百度]()次数最多的IP。 

 假设内存无穷大，我们可以用常规的HashMap(ip，value)来统计ip出现的频率，统计完后利用[排序]()[算法]()得到次数最多的IP，这里的[排序]()[算法]()一般是堆[排序]()或快速[排序]()。 

 但考虑实际情况，我们的内存是有限的，所以无法将海量日志数据一次性塞进内存里，那应该如何处理呢？很简单，分而治之！即将这些IP数据通过Hash映射[算法]()划分为多个小文件，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文件中出现频率最大的IP，最后在这1000个最大的IP中，找出那个频率最大的IP，即为所求（是不是很像Map Reduce的思想？）。 

 这里鬼仔再多说一句：Hash取模是一种等价映射[算法]()，不会存在同一个元素分散到不同小文件中的情况，这保证了我们分别在小文件统计IP出现频率的正确性。我们对IP进行模1000的时候，相同的IP在Hash取模后，只可能落在同一个小文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模（如模1000），必定仍然相等。 

 总结一下，该类题型的解决方法分三步走： 

1.  分而治之、hash映射； 
2.  HashMap（或前缀树）统计频率； 
3.  应用[排序]()[算法]()（堆[排序]()或快速[排序]()）。 

 如果将题目改为：海量日志数据，提取出某日访问[百度]()次数最多的前N个IP。牛油们知道怎么处理吗？把答案写在评论区吧～ 

##  2、搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询长度不超过 255 字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。 

 我们首先分析题意：一千万个记录，除去重复后，实际上只有300万个不同的记录，每个记录假定为最大长度255Byte，则最多占用内存为：3M*1K/4=0.75G<1G，完全可以将所以查询记录存放在内存中进行处理。相较于第一道题目，这题还更简单了，直接HashMap（或前缀树）+堆排序即可。 

 具体做法如下： 

1.  遍历一遍左右的Query串，利用HashMap（或前缀树）统计频率，时间复杂度为O(N)，N=1000万； 
2.  建立并维护一个大小为10的最小堆，然后遍历300万Query的频率，分别和根元素（最小值）进行对比，最后找到Top K，时间复杂度为N‘logK，N‘=300万，K=10。 

##  3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。 

 经过前两道题的训练，第三道题相信大家已经游刃有余了，这类题型都有相同的特点：文件size很大，内存有限，解决方法还是经典三步走：分而治之 + hash统计 + 堆/快速排序。 

 具体做法如下： 

1.  分而治之、hash映射：遍历一遍文件，对于每个词x，取hash(x)并模5000，这样可以将文件里的所有词分别存到5000个小文件中，如果哈希函数设计得合理的话，每个文件大概是200k左右。就算其中有些文件超过了1M大小，还可以按照同样的方法继续往下分，直到分解得到的小文件的大小都不超过1M； 
2.  HashMap（或前缀树）统计频率：对于每个小文件，利用HashMap（或前缀树）统计词频； 
3.  堆排序：构建最小堆，堆的大小为100，找到频率最高的100个词。 

##  4、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？ 

 每个url是64字节，50亿*64=5G×64=320G，内存限制为4G，所以不能直接放入内存中。怎么办？分而治之！ 

 具体做法如下： 

1.  遍历文件a中的url，对url进行hash(url)%1000，将50亿的url分到1000个文件中存储（a0，a1，a2.......），每个文件大约300多M，对文件b进行同样的操作，因为hash函数相同，所以相同的url必然会落到对应的文件中，比如文件a中的url1与文件b中的url2相同，那么它们经过hash(url)%1000也是相同的。即url1落入第n个文件中，url2也会落入到第n个文件中。 
2.  遍历a0中的url，存入HashSet中，同时遍历b0中的url，查看是否在HashSet中存在，如果存在则保存到单独的文件中。然后以此遍历剩余的小文件即可。



```latex
在上篇中，问题原形是在海量数据中找出重复次数最多的一个/前N个数据，我们的解决方法是： 分而治之/Hash映射 + HashMap/前缀树统计频率 + 堆/快速/归并排序。

今天给大家介绍下海量数据处理题的另一种常见题型：在海量数据中找出第k大/中位数/不重复或重复的数字，解决方法关键还是在于分治，通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内处理数据。
```



## 4、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 

 整数int有4个byte，所有整数个数有2^32，这里可以继续使用分而治之、hash映射的方法，即对于每个整数x，取hash(x)并模N，N代表划分的小文件个数，这样相同的整数会存入同一个文件，接着通过HashMap统计每个小文件中整数出现的频率（key为整数，value为频率），最后value为1的整数即为所求。 

  除此之外，我们还可以使用一种特殊的数据结构：位图（BitMap）。 

 

  位图的思想是用bit数组来记录0-1两种状态，可以将具体数据映射到这个bit数组的对应位置，bit数组中0表示数据存在，1表示数据不存在。举个例子，利用位图表示0-5中的元素，0-5中只有6个数，所以用6bit足以表示，例如3可以表示为[0,0,0,1,0,0]。位图在大量数据查询、去重等应用场景中使用的比较多，这个[算法]()具有比较高的空间利用率。 

 回到该题，要找出不重复的整数，那么一个整数可以有三种状态，即不存在、存在1次、存在多次，根据题目需要找出的是存在1次的整数。对于三种状态只用0或1肯定是表示不了的，采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）。具体做法为：首先遍历所有整数，查看对应位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。最后遍历位图，找出01对应的整数，即为2.5亿整数中只出现一次的整数。 

 我们也可以采用两个BitMap，即第一个Bitmap存储的是整数是否出现，接着，在之后的遍历先判断第一个BitMap里面是否出现过，如果出现就设置第二个BitMap对应的位置也为1，最后遍历BitMap，仅仅在一个BitMap中出现过的元素，就是不重复的整数。 

##  5、已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。 

 这类题目使用位图法最为简单，每个号码八位数，不考虑实际情况，8位最多99 999 999，一共有10^8种情况，也就是需要10^8位bit，大概12.5M内存即可。申请一个数组，遍历所有号码，将号码对应的bit置为1，最后统计bit位1的数量即为不同的号码数。 

##  6、5亿个int整数找它们的中位数 

 我们先明确中位数的定义：中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小，如果这组数据有偶数个，那么取中间的两个数值的平均数作为中位数。 

 **解法一：**当内存不足以存放5亿个int整数时，我们依然使用分而治之的方法，但hash映射分成小文件的时候需要注意，我们要保证把数据分散到不同文件中时仍然保持着顺序，即按数值大小进行分流，这样才能找到正确的中位数。 

-  我们遍历这5亿个int整数时，考虑其二进制的最高位，按照最高位（符号位，0表示正数，1表示负数）进行二分，即最高位为1存入文件a，最高位为0存入文件b，这样文件a中的数是一定比文件b中的数小。 
-  统计文件a和文件b中的整数个数，如果文件a和文件b中的整数个数相同，那么中位数则是文件a中的最小值和文件b中的最大值的平均值。如果文件a中的整数个数小于文件b，那么中位数肯定在文件b中，反之亦然。 
-  如果文件a或文件b中的整数还是无法直接读取进内存中，那么继续使用上个步骤的方法进行分流，并判断中位数所处的位置，直到中位数所在的那部分数据大小可以直接放到内存中，然后对这部分[排序]()，计算出中位数的值。 

 **解法二：**空间换时间，巧妙利用大小堆。这其实可以用力扣295题（数据流的中位数）的方法进行解答，我摘抄下高赞的解法给同学们参考下： 

-  **题目：** 

>  ![img](%E6%99%BA%E5%8A%9B%E9%A2%98%E4%B8%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%A2%98.assets/B22AC9C4268657D03AA720DA3AFA8148) 

-  **解答：** 

> ​    ![img](%E6%99%BA%E5%8A%9B%E9%A2%98%E4%B8%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%A2%98.assets/5B771A81C762BE875F354B8DAC5E75CE)   

-  **代码（Java）：** 

```java
class MedianFinder {
    PriorityQueue<Integer> l = new PriorityQueue<>((a,b)->b-a);
    PriorityQueue<Integer> r = new PriorityQueue<>((a,b)->a-b);

    public void addNum(int num) {
        int s1 = l.size(), s2 = r.size();
        if (s1 == s2) {
            if (r.isEmpty() || num <= r.peek()) {
                l.add(num);
            } else {
                l.add(r.poll());
                r.add(num);
            }
        } else {
            if (l.peek() <= num) {
                r.add(num);
            } else {
                r.add(l.poll());
                l.add(num);
            }
        }
    }

    public double findMedian() {
        int s1 = l.size(), s2 = r.size();
        if (s1 == s2) {
            return (l.peek() + r.peek()) / 2.0;
        } else {
            return l.peek();
        }
    }
}

```

>  **时间复杂度：**addNum 函数的复杂度为 O(logn)；findMedian 函数的复杂度为 O(1) 
>
>    **空间复杂度：**O(n)



