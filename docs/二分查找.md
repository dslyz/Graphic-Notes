# 二分查找（原理+题解）

## 二分查找的思想

假设要在电话簿中找一个名字以K打头的人，可以从头开始翻页，直到进入以K打头的部分。但你很可能不这样做，而是从中间开始，因为你知道以K打头的名字在电话簿中间。

又假设要在字典中找一个以O打头的单词，你也将从中间附近开始。

现在假设你登录Facebook。当你这样做时，Facebook必须核实你是否有其网站的账户，因此必须在其数据库中查找你的用户名。如果你的用户名为karlmageddon, Facebook可从以A打头的部分开始查找，但更合乎逻辑的做法是从中间开始查找。

**这是一个查找问题，在前述所有情况下，都可使用同一种算法来解决问题，这种算法就是二分查找。**

下面的示例说明了二分查找的工作原理。我随便想一个1～100的数字

![image-20210222120806874](D:\docsify-demo\docs\二分查找.assets\image-20210222120806874.png)

你的目标是以最少的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。

假设你从1开始依次往上猜，猜测过程会是这样。

![image-20210222120846264](D:\docsify-demo\docs\二分查找.assets\image-20210222120846264.png)

这是**简单查找**，更准确的说法是傻找。每次猜测都只能排除一个数字。如果我想的数字是99，你得猜99次才能猜到！

更佳的查找方法是使用二分查找：

下面是一种更佳的猜法。从50开始。

![image-20210222121016571](D:\docsify-demo\docs\二分查找.assets\image-20210222121016571.png)

小了，但排除了一半的数字！至此，你知道1～50都小了。接下来，你猜75。

![image-20210222121042503](D:\docsify-demo\docs\二分查找.assets\image-20210222121042503.png)

大了，那余下的数字又排除了一半！使用二分查找时，你猜测的是中间的数字，从而每次都将余下的数字排除一半。接下来，你猜63（50和75中间的数字）。

![image-20210222121108117](D:\docsify-demo\docs\二分查找.assets\image-20210222121108117.png)

这就是二分查找，每次猜测排除的数字个数如下。

![image-20210222121141798](D:\docsify-demo\docs\二分查找.assets\image-20210222121141798.png)

假设你要在字典中查找一个单词，而该字典包含240000个单词，你认为每种查找最多需要多少步？

![image-20210222121218719](D:\docsify-demo\docs\二分查找.assets\image-20210222121218719.png)

如果要查找的单词位于字典末尾，使用简单查找将需要240000步。使用二分查找时，每次排除一半单词，直到最后只剩下一个单词。

![image-20210222121237129](D:\docsify-demo\docs\二分查找.assets\image-20210222121237129.png)

因此，使用二分查找只需18步——少多了！一般而言，对于包含n个元素的列表，用二分查找最多需要log n步，而简单查找最多需要n步。

**注意：仅当列表是有序的时候，二分查找才管用。**

## 二分查找的习题

### 习题01：剑指 Offer 53 - I. 在排序数组中查找数字 I

统计一个数字在排序数组中出现的次数。
$$
示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
$$

$$
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
$$

限制：

0 <= 数组长度 <= 50000



**解题思路分析：**设数组的左界和右界索引分别为left和right，设要求得的target1值的左右边界分别为targetLeft和targetRight，使用二分法分别求得target的左右边界，返回targetRight-tagetLeft-1即为所求的的target出现次数。

![image-20210225133710644](D:\docsify-demo\docs\二分查找.assets\image-20210225133710644.png)

**判断规则为：**

1.如果nums[mid]<target,target在[mid+1,right]中，需要执行left=mid+1;

2.如果nums[mid]>target,target在[left,mid-1]中，需要执行right=mid-1；

3.如果nums[mid]=target,右边界在[mid+1,right]中，执行left=mid+1；

左边界在[left,mid-1]中，执行right=mid-1;

* 时间复杂度：O（log n)
* 空间复杂度：O（1)

题解：两次二分分别求target左右边界

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        //求目标值右边界
        while(left<=right)
        {
            int mid=(left+right)/2;
            if(nums[mid]<=target){
                left=mid+1;
            }
            else right=mid-1;
        }
        int targetRight=left;
        //数组中没有target。提前返回
        if(right>=0&&nums[right]!=target)
        {
            return 0;
        }
        //求目标值左边界
        left=0;
        right=nums.size()-1;
        while(left<=right)
        {
            int mid=(left+right)/2;
            //注意这里没有等于条件，求左边界
            if(nums[mid]<target){
                left=mid+1;
            }
            else right=mid-1;
        }
        int targetLeft=right;
        
        return targetRight-targetLeft-1;
        

    }
};
```

一种更优解（只需要求右边界而无需求左边界）：

为简化代码，可将二分查找右边界的代码封装至函数 `helper()` 。

![image-20210225135751595](D:\docsify-demo\docs\二分查找.assets\image-20210225135751595.png)

如此，只需要计算出target的右边界与target-1的右边界即可求出target个数。

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        return helper(nums,target)-helper(nums,target-1);
    }

    //求target的右边界辅助函数
    int helper(vector<int>& nums,int tar)
    {
        int left=0,right=nums.size()-1;
        while(left<=right)
        {
            int mid=(left+right)/2;
            if(nums[mid]<=tar)
            {
                left=mid+1;
            }
            else right=mid-1;
        }
        //返回tar右边界的下标
        return left;
    }
};
```

